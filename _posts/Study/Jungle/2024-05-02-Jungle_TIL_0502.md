---
no_link_title:    false
no_excerpt:       false
hide_image:       true

layout:           post
cover:            false
sidebar:          false
order:            0      
toc:              true

image:
  path:           /assets/img/banner/jungle_banner.png

title:            크래프톤 정글 7주차 개발일지
hide_title:       false
description:      KRAFTON JUNGLE Week 07
hide_description: false
date:             2024-05-02 12:00:00
featured:         false
categories:       [study]
tag:              [jungle]
---

## JUNGLE 240502 (W07)

* toc
{:toc}

### 네트워크 계층
- 네트워크: 컴퓨터나 기타 기기들이 리소스를 공유하거나 데이터를 주고받기 위해 유선 혹은 무선으로 연결된 통신 체계
  - 네트워크의 기능
    1. 애플리케이션 목적에 맞는 통신 방법 제공
    2. 신뢰할 수 있는 데이터 전송 방법 제공
    3. 네트워크 간의 최적의 통신 경로 결정
    4. 목적지로 데이터 전송
    5. 노드 사이의 데이터 전송
- 네트워크 프로토콜: 네트워크 통신을 하기 위해서 통신에 참여하는 주체들이 따라야하는 형식, 젍차, 규약 등
- 인터넷 프로토콜 스위트: 인터넷에서 컴퓨터들이 정보를 주고받는 데 사용되는 프로토콜의 집합

<br>

> 💡 네트워크 계층 구조를 나누는 이유
> - 통신이 일어나는 과정에서 데이터의 흐름을 한눈에 파악하기 쉽고 통신 과정 중 문제 발생 시 
> 다른 단계의 장비 및 소프트웨어를 건드리지 않고 통신 장애를 일으킨 단계에서 해결할 수 있기 때문
> - 또한, 각 계층들은 다른 계층에 영향을 받지 않도록 설계되어 있어 독립적으로 발전 가능
> - 즉, 다양한 유형의 프로토콜에 적응할 수 있는 유연성을 제공

OSI Model (7 layer) - 범용적인 네트워크 구조 <br>
TCP/IP stack (4 layer) - 인터넷에 특화된 네트워크 구조
{:.note}

#### OSI 7계층
> - 네트워크가 프로토콜을 통해 통신하는 과정을 7단계로 나누어 계층 간 상호 작용하는 방식
> - 각 레이어에 맞게 프로토콜이 세분화되어 구현되어 있음
> - 각 레이어의 프로토콜은 하위 레이어의 프로토콜이 제공하는 기능을 사용하여 동작

1. 7계층 - 애플리케이션 계층 (응용 계층)
   - 사용자들이 사용하는 애플리케이션 목적에 맞는 통신 방법을 제공하는 계층
   - 이 계층은 사용자가 응용 프로그램을 통해 네트워크 서비스에 접근할 수 있도록 사용자 인터페이스 제공
   - 실제 응용 프로그램에서 사용하는 프로토콜들이 응용계층에서 동작
   - EX. 파일 전송에 사용되는 FTP, 이메일 전송에 사용되는 SMTP, 웹 서버에 접속할 때 사용하는 HTTP 등
   
2. 6계층 - 프레젠테이션 계층 (표현 계층)
   - 애플리케이션 간의 통신에서 데이터 표현의 차이를 해결하기 위해 서로 다른 형식으 로 변환해주거나 공통 형식을 제공하는 등 데이터의 표현 방식을 결정해주는 계층
   - 송신측에서는 수신자가 이해할 수 있는 형태로 데이터를 변환하며 수신측에서는 응용 계층에 맞는 형태로 변환
   - 그래픽 정보를 JPEG로 변환하거나 동영상을 MPEG 형태로 변환하여 송수신하는 작업이 수행됨
   - 데이터 형식을 변환하는 이유: 통신하는 두 기기가 특성이 같다는 보장이 없기 때문

3. 5계층 - 세션 계층
   - 애플리케이션 간의 통신에서 세션을 관리하며 포트를 기반으로 통신을 연결
   - 네트워크 장치 간의 통신 방식을 결정할 수 있으며, 세션을 연결하고 해제하며 전송 중단 시 동기화 기능을 통해 데이터를 복구할 수 있음
   - 동기화 기능: 데이터 전송 시 오류가 발생했을 경우 제일 최근에 데이터 전송이 성공한 동기점부터 다시 데이터를 재전송하여 작업을 이어갈 수 있도록 하는 기능

4. 4계층 - 전송 계층
   - 데이터 전송을 담당하는 계층
   - 포트 번호를 기반으로 송신자와 수신자 간의 신뢰성있고 효율적인 데이터를 전송하기 위해 흐름 제어, 오류 제어 등의 기능을 제공

5. 3계층 - 네트워크 계층
   - 실제 네트워크 간의 라우팅을 담당하는 계층 
   - IP 주소 등을 통해 데이터를 목적지까지 가장 안전하고 빠르게 전달하는 역할
   - 라우터를 통해 경로를 선택하여 경로에 따라 패킷을 전달
   - 상대방이 제대로 받았는지에 대해서는 보장하지 않는 비연결형적인 특징을 가지고 있음 (상위 계층에서 패킷 분실시 오류 복구)

6. 2계층 - 데이터링크 계층
   - 장비의 고유 주소인 MAC 주소를 이용하여 노드 간 데이터를 전송하는 계층
   - IP 주소를 가지고 MAC 주소를 찾거나 MAC 주소를 가지고 IP 주소를 찾아준다.
   - 그 과정에서 이더넷 프레임을 통해 에러 확인, 흐름 제어, 접근 제어 등의 기능을 수행 (안전한 정보 전달을 위해)

7. 1계층 - 물리 계층
   - 최하위 계층으로 하드웨어 같은 물리적인 매체를 통해 bits 단위로 데이터를 전송
   - 데이터 링크 계층으로부터 프레임을 받아 0과 1로 이루어져 있는 전기적 신호로 데이터를 변환하여 구리나 광섬유 또는 무선 통신 매체를 통해 전송
   - 단순히 데이터 전달의 역할만을 수행하며 오류 제어 등의 기능은 수행하지 않음

#### TCP / IP 스택
> - 실제 인터넷 통신 시 기반이 되는 모델
> - 애플리케이션, 전송, 인터넷, 링크 4계층으로 이루어져 있음

1. 4계층 - 애플리케이션 계층
   - OSI 7계층에서 5, 6, 7 계층에 해당
2. 3계층 - 전송 계층
   - OSI 7계층에서 4계층에 해당
3. 2계층 - 인터넷 계층
   - OSI 7계층에서 3계층에 해당
4. 1계층 - 링크 계층 (네트워크 접근 계층)
   - OSI 7계층에서 1, 2 계층에 해당

> 💡 TCP vs UDP
> 1. 연결 지향성 (TCP) vs 비 연결성 (UDP)
>    - TCP는 연결 지향적. 즉, 통신하기 전에 연결 설정 단계를 거치고, 연결이 설정된 후 데이터를 안정적으로 전송함. 이로 인해 데이터의 순서가 유지되며, 전송 중 손실된 데이터를 재전송 가능
>    - UDP는 비 연결성. 따라서 데이터를 전송하기 전에 사전 연결 설정 과정이 없으며, 데이터 그램을 전송하는 동안 데이터의 손실이나 순서 변경 발생 가능
> 2. 신뢰성
>    - TCP는 신뢰성 있는 데이터 전송 보장. 데이터가 손실되거나 손상될 경우 재전송 메커니즘이 있어 데이터의 완전성이 보존
>    - UDP는 신뢰성이 낮음. 데이터가 전송될 때 오류를 감지하거나 복구할 수 있는 메커니즘이 없으므로 데이터의 손실이나 손상 발생 가능
> 3. 흐름 제어 및 혼잡 제어
>    - TCP는 흐름 제어와 혼잡 제어를 통해 네트워크 상황에 따라 데이터 전송 속도 조절
>    - UDP는 이러한 제어 메커니즘이 없으므로 전송되는 데이터 양이 네트워크의 용량을 초과할 경우 혼잡 발생 가능
> 4. 사용 사례
>    - TCP는 파일 전송, 웹 브라우징, 이메일 전송 등과 같이 신뢰성이 중요한 응용 프로그램에 주로 사용
>    - UDP는 실시간 스트리밍, 온라인 게임, DNS 등과 같이 신속한 데이터 전송이 우선시 되는 응용 프로그램에 주로 사용

### 클라이언트 - 서버 모델
- 리소스를 사용하는 앱(클라이언트)과 리소스가 존재하는 곳(서버)을 분리시키는 모델 (2-tier 아키텍쳐)
- 클라이언트는 웹/앱을 이용하는 사용자 (웹 브라우저를 통해 서버에 원하는 데이터 요청)
- 브라우저는 클라이언트가 이용하는 도구로써 사용자와 상호작용을 함 
- 서버는 클라이언트의 요청을 처리해서 응답하게 됨

<br>

**클라이언트 - 서버 트랜잭션의 4단계**
1. 클라이언트가 서비스를 필요로 할 때, 클라이언트는 한 개의 요청을 서버에 보내는 것으로 트랜잭션 개시
2. 서버는 요청을 받고 해석하고, 자신의 자원들을 적절한 방법으로 조작
3. 서버는 응답을 클라이언트로 보내고, 그 후에 다음 요청을 기다림
4. 클라이언트는 응답을 받고 이것을 처리 

### Socket
> - 네트워크 통신에서 사용되는 추상화된 인터페이스
> - 프로그램이 네트워크에서 데이터를 송수신할 수 있도록, "네트워크 환경에 연결할 수 있게 만들어진 연결부"
> - 두 개의 프로세스가 소켓을 통해 데이터 통신을 위한 연결을 만들기 위해서는 연결 요청을 보내는 소켓(Client Socket)과 요청을 받아들이는 소켓(Server Socket) 두 종류가 필요하다.

#### Socket API 실행 흐름
1. **클라이언트 소켓** : 소켓 생성 (`socket`) -> 서버 측에 연결 (`connect`) 요청 -> 서버 소켓에서 연결이 받아들여지면 데이터를 송수신 (`send/recv`) -> 모든 처리가 완료되면 소켓을 닫음 (`close`)
2. **서버 소켓** : 소켓 생성 (`socket`) -> 서버가 사용할 IP 주소와 포트 번호를 생성한 소켓에 결합 (`bind`) -> 클라이언트로부터 연결 요청이 수신되는지 주시 (`listen`) -> 요청이 수신되면 요청을 받아들여 (`accept`) 데이터 통신을 위한 소켓 생성 -> 새로운 소켓을 통해 연결이 성립되면 데이터 송수신 (`send/recv`) -> 모든 처리가 완료되면 소켓을 닫음 (`close`)

#### Socket의 종류
1. **스트림 소켓**
   - TCP 프로토콜에서 사용됨
   - 연결 지향적이며, 데이터의 신뢰성과 순서가 보장
   - 양방향 통신을 지원함
   - `SOCK_STREAM` 유형으로 정의

2. **데이터그램 소켓**
   - UDP 프로토콜에서 사용됨
   - 연결 없이 데이터를 전송
   - 신뢰성과 데이터의 순서가 보장되지 않음
   - 데이터그램을 통해 한 번에 하나의 메세지만 전송됨
   - `SOCK_DGRAM` 유형으로 정의

3. **RAW 소켓**
   - 네트워크 프로토콜의 상위 수준 추상화를 제공하지 않고, 직접적으로 네트워크 계층에 엑세스
   - 패킷의 생성 및 해석에 대한 전체 제어를 제공
   - 네트워크 스니핑, 패킷 조작, 보안 도구 등에 사용
   - `SOCK_RAW` 유형으로 정의

#### Socket 함수 
1. `socket()` : 소켓 생성 함수
```cpp
int socket(int domain, int type, int protocol);
```
  - `domain`: 인터넷을 통해 통신할지, 같은 시스템 내에서 프로세스끼리 통신할지의 여부를 설정
  - `type`: 데이터의 전송 형태 지정
  - `protocol`: 통신에 있어 특정 프로토콜을 지정하기 위한 변수 (보통 0)

2. `bind()` : 소켓에 주소를 할당하는 함수
```cpp
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```
  - `sockfd` : 소켓 파일 디스크립터
  - `addr` : 할당할 주소 정보를 담고 있는 `sockaddr` 구조체의 포인터
  - `addrlen`: `addr` 구조체의 크기

3. `listen()` : 서버 소켓에서 클라이언트의 연결 요청을 수신할 수 있도록 설정
```cpp
int listen(int sockfd, int backlog);
```
  - `sockfd` : 소켓 파일 디스크립터
  - `backlog` : 대기열 크기, 동시에 대기할 수 있는 연결 요청의 최대 수를 지정

4. `accept()` : 클라이언트의 연결 요청을 수락하고 새로운 소켓을 생성하여 통신을 위한 새로운 연결을 만듬
```cpp
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
```
  - `sockfd` : 소켓 파일 디스크립터
  - `addr` : 할당할 주소 정보를 담고 있는 `sockaddr` 구조체의 포인터
  - `addrlen`: `addr` 구조체의 크기

5. `connect()` : 클라이언트 소켓에서 서버에 연결을 요청하는 함수
```cpp
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```
  - `sockfd` : 소켓 파일 디스크립터
  - `addr` : 할당할 주소 정보를 담고 있는 `sockaddr` 구조체의 포인터
  - `addrlen`: `addr` 구조체의 크기

6. `send()/recv()` : 소켓을 통해 데이터를 주고 받는 함수
```cpp
ssize_t send(int sockfd, const void *buf, size_t len, int flags);
ssize_t recv(int sockfd, void *buf, size_t len, int flags);
```
  - `sockfd` : 소켓 파일 디스크립터
  - `buf` : 데이터를 보내거나 받을 버퍼의 포인터
  - `len` : 보내거나 받을 데이터의 크기
  - `flags` : 옵션 플래그

7. `close()` : 소켓을 닫고 해당 소켓 자원을 해체하는 함수
```cpp
int close(int sockfd);
```
  - `sockfd` : 소켓 파일 디스크립터

### HTTP (HyperText Transfer Protocol)
> 텍스트 기반의 통신 규약으로 인터넷에서 데이터를 주고받을 수 있는 프로토콜

#### HTTP 동작
클라이언트가 브라우저를 통해서 어떠한 서비스를 요청(request)을 하면 서버에서는 해당 요청사항에 맞는 결과를 찾아서 사용자에게 응답(response)하는 형태로 동작

#### Request(요청)
- 클라이언트가 웹 서버에게 보내는 메세지
- 요청은 일반적으로 클라이언트가 웹 페이지를 요청하거나, 리소스를 요청할 때 생성됨
- 구성 요소
  - 메서드 (Method) : 요청의 종류를 나타내는 문자열 (GET, POST, PUT, DELETE)
  - URL (Uniform Resource Locator) : 

### 추가 용어 정리
> 💡 라우팅 (Routing) vs 포워딩 (Forwarding)
> 1. 라우팅 (Routing)
>   - 라우팅은 네트워크에서 데이터 패킷의 최적 경로를 결정하는 프로세스
>   - 라우팅은 보통 라우터나 라우팅 테이블을 통해 이루어짐. 라우터는 목적지 주소를 분석하여 패킷이 네트워크를 통해 전달되어야 할 다음 호스트 또는 라우터를 결정
>   - 라우팅은 여러 가지 요소를 고려하여 최적의 경로를 결정. (경로의 비용, 대역폭, 지연, 현재 네트워크 상태 등)
> 2. 포워딩 (Forwarding)
>   - 포워딩은 라우터가 데이터 패킷을 결정된 경로를 따라 다음 호스트나 라우터로 전달하는 프로세스
>   - 라우터가 패킷을 받으면, 패킷의 목적지 주소를 검사하여 라우팅 테이블을 사용하여 적절한 포트로 패킷 전송
>   - 포워딩은 패킷이 라우터를 통해 실제로 전달되는 과정을 의미, 라우터의 주요 작업 중 하나
> 즉, 라우팅은 최적 경로를 결정하는 프로세스, 포워딩은 결정된 경로를 따라 패킷을 전송하는 프로세스

<br>

> 💡 데이터 패킷? <br>
> 네트워크 통신에서 전송되는 데이터의 작은 조각. 네트워크 통신에서 데이터는 패킷으로 나누어져 전송됨.
> 1. 헤더 (Header) : 패킷의 제어 정보를 담고 있는 부분. 출발지 주소, 목적지 주소, 패킷 크기, 패킷 순서 등의 정보가 포함됨
> 2. 페이로드 (Payload) : 실제 전송되는 데이터. 패킷의 페이로드에는 응용 프로그램이 전송하려는 정보가 포함됨. 예를 들어, 이메일의 내용, 웹 페이지의 HTML 코드, 파일의 내용 등
> 3. 트레일러 (Trailer) : 일부 프로토콜에서는 패킷의 끝에 트레일러 추가. 트레일러에는 오류 검출을 위한 정보가 포함됨

<br>

> 💡 IP 주소 vs 포트 번호
> 1. IP 주소
>    - IP 주소는 네트워크에서 장치를 식별하는 데 사용됨
>    - 이 주소는 네트워크 계층에서 사용되며, 데이터가 출발지에서 목적지로 라우팅되는 데 사용
>    - IP 주소는 전 세계적으로 고유하며 IPv4와 IPv6의 2가지 주요 버전이 있음
> 2. 포트 번호
>    - 포트 번호는 네트워크 통신에서 특정 프로그램이나 서비스를 식별하는 데 사용됨
>    - 이는 전송 계층에서 사용됨
>    - 한 대의 컴퓨터에는 다양한 네트워크 서비스가 실행될 수 있으며, 각 서비스는 고유한 포트 번호를 가짐

<br>

> 💡 게이트웨이
> - 네트워크에서 서로 다른 네트워크 간에 데이터를 전송하는 데 사용되는 장치나 시스템
> - 서로 다른 네트워크 프로토콜이나 통신 프로토콜 간의 변환을 담당하며, 데이터를 다른 네트워크로 라우팅하는 역할

<br>

> 💡 파일 디스크립터
> - 운영 체제에서 파일이나 입출력 장치와 관련된 리소스를 식별하는 데 사용되는 정수 값
> - 일반적으로 파일 시스템에서 열려 있는 파일이나 입출력 장치를 가리키는데 사용됨
> - 소켓은 일종의 파일로 간주되기 때문에 소켓을 열거나 통신을 위해 파일 디스크립터 사용
> - 이 파일 디스크립터를 통해 소켓에 데이터를 읽거나 쓰고, 소켓을 닫을 수 있음
> - 0: 표준 입력 (Standard Input)
> - 1: 표준 출력 (Standard Output)
> - 2: 표준 에러 (Standard Error)

<br>

> 💡 CGI, Web Server, MIME Type
> 1. CGI (Common Gateway Interface)
>    - 웹 서버에서 동적인 웹 페이지를 생성하기 위해 사용되는 표준 인터페이스
>    - CGI를 사용하면 웹 서버와 외부 프로그램 사이에서 데이터를 주고받을 수 있음
>    - 보통 CGI는 웹 서버와 웹 어플리케이션 사이에 중개자 역할을 함
>    - 웹 서버는 클라이언트의 요청을 받아 CGI를 실행하고, CGI는 외부 프로그램이나 스크립트를 실행하여 동적인 콘텐츠를 생성한 후에 이를 웹 서버에 반환
> 2. Web Server
>    - 클라이언트는 HTTP 요청을 받아들이고, 웹 페이지와 다른 리소스를 제공하는 소프트웨어
>    - 주요 기능
>      1. HTTP 요청의 처리 : 클라이언트로부터 HTTP 요청을 받아들이고, 요청에 따른 동작 수행
>      2. 정적 파일 제공 : HTML 파일, 이미지, CSS 파일, Java Script 파일 등과 같은 정적인 웹 리소스를 클라이언트에게 제공
>      3. 동적 콘텐츠 처리 : 스크립트 언어나 웹 애플리케이션 서버를 사용하여 동적인 콘텐츠 생성하고 클라이언트에게 제공
>      4. 세션 관리 : 클라이언트와 서버 간의 상태를 유지하고, 필요한 경우에 세션을 관리. 이를 통해 사용자의 상태를 추적하고 사용자 간의 데이터 공유 가능
>      5. 보안 : 보안 기능을 제공하여 악의적인 공격으로부터 시스템을 보호하고, 데이터의 안전성 유지
>      6. 로그 기록 : 클라이언트의 요청과 서버의 응답에 관한 로그를 기록하여 트래픽을 모니터링하고 분석 가능
> 3. MIME Type (Multipurpose Internet Mail Extensions)
>    - 인터넷에서 데이터를 전송할 때 데이터의 타입을 지정하기 위한 메커니즘
>    - 데이터의 종류를 나타내는 문자열로 보통 파일의 확장자를 기반으로 결정